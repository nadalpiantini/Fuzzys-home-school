# Directrices de Desarrollo - Fuzzys Home School
# Archivo de configuración para Claude AI Assistant

## PRINCIPIOS FUNDAMENTALES

### Operación Bisturí
- No tocar más nada que lo que se está arreglando en el momento
- Cambios quirúrgicos y precisos
- Evitar modificaciones innecesarias

### Efecto Mariposa
- Calcular el efecto del cambio propuesto en las demás configuraciones y funciones
- No dañar lo que esté previamente aprobado o funcional
- Análisis de impacto antes de implementar

### Cadena de Pensamientos
- Buscar soluciones profesionales para los problemas
- Ser creativo al encontrar soluciones
- Todo con visión de producción deploy
- Nada provisional ni mockup

## PATRONES DE CÓDIGO

### Cliente Supabase - Patrón Factory
**PROBLEMA**: Evitar crear el cliente Supabase en top-level (explota en build)

**ANTES (mal ejemplo)**:
```typescript
// lib/supabase.ts
import { createClient } from '@supabase/supabase-js';
const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_ANON_KEY!); // ❌ top-level
export default supabase;
```

**DESPUÉS (correcto)**:
```typescript
// lib/supabase.server.ts
import { createClient } from '@supabase/supabase-js';

export function getSupabaseServer() {
  const url = process.env.SUPABASE_URL;
  const key = process.env.SUPABASE_ANON_KEY; // o SERVICE_ROLE en endpoints admin
  if (!url || !key) {
    // No explotes en import; valida cuando lo uses
    throw new Error('Supabase env vars missing at runtime');
  }
  return createClient(url, key, { auth: { persistSession: false } });
}
```

**En API routes**:
```typescript
import { NextResponse } from 'next/server';
import { getSupabaseServer } from '@/lib/supabase.server';

export const dynamic = 'force-dynamic';        // evita SSG en esta ruta
export const revalidate = 0;                   // no cachear
export const runtime = 'nodejs';               // si usas features no soportadas por Edge

export async function POST(req: Request) {
  try {
    const supabase = getSupabaseServer();      // ✅ se crea en tiempo de request
    const body = await req.json();
    // ... usa supabase
    return NextResponse.json({ ok: true });
  } catch (err: any) {
    // Si faltan envs en runtime, responde 500 sin romper el build
    return NextResponse.json({ ok: false, error: err?.message ?? 'Server error' }, { status: 500 });
  }
}
```

### Reglas de Implementación
1. **Factory Functions**: Usar funciones que instancian el cliente cuando se llaman
2. **Lazy Loading**: No instancias globales "al importar"
3. **Error Handling**: Validar env vars en runtime, no en import
4. **Build Safety**: Evitar ejecución de código en tiempo de build

### Build Safety - Rutas API
**PROBLEMA**: Evitar que Next.js ejecute rutas API en build time

**SOLUCIÓN**: Agregar exports de configuración a todas las rutas API
```typescript
// En cada route.ts
export const dynamic = 'force-dynamic';  // evita SSG en esta ruta
export const revalidate = 0;            // no cachear
export const runtime = 'nodejs';         // si usas features no soportadas por Edge
```

**SEPARACIÓN DE TIPOS Y UTILIDADES**:
- Si necesitas tipos/utilidades desde rutas API, ponlos en archivos separados sin side effects
- Solo tipos y funciones puras en archivos compartidos
- Evitar importar código de rutas API desde componentes que se renderizan en build

## ARQUITECTURA

### Estructura de Clientes
- `lib/supabase/client.ts` - Cliente browser (puede ser top-level)
- `lib/supabase/server.ts` - Factory functions para server
- `lib/brain-engine/core/db.ts` - Factory function con lazy loading

### Patrones de Uso
- **Browser**: Cliente directo para componentes client-side
- **Server**: Factory functions para API routes y server components
- **Brain Engine**: Lazy singleton pattern

## CONVENCIONES

### Naming
- `getSupabaseServer()` - Factory function para server
- `getServiceRoleClient()` - Factory function para admin operations
- `sb()` - Lazy singleton para brain engine

### Error Handling
- Validar env vars en runtime
- No fallar en build time
- Respuestas HTTP apropiadas para errores

### Performance
- Lazy loading cuando sea posible
- Singleton pattern para reutilización
- Evitar recreación innecesaria de clientes

## NOTAS DE IMPLEMENTACIÓN

- Si alguna librería obliga a crear el cliente en módulo compartido, exportar factory o getter lazy
- Nada de instancias globales "al importar"
- Mantener compatibilidad con código existente
- Testing de cambios en desarrollo antes de deploy

## IMPLEMENTACIÓN COMPLETADA ✅

### Cliente Supabase Refactorizado
- ✅ `lib/supabase/server.ts` - Factory functions implementadas
- ✅ `lib/brain-engine/core/db.ts` - Lazy loading mejorado
- ✅ Backward compatibility mantenida

### Build Safety - Rutas API
- ✅ 19 rutas API con exports de dynamic agregados
- ✅ Scripts automatizados para agregar y limpiar exports
- ✅ Build exitoso sin errores de compilación
- ✅ Separación de tipos y utilidades documentada

### Scripts de Automatización
- ✅ `scripts/add-dynamic-exports.js` - Agregar exports automáticamente
- ✅ `scripts/fix-duplicate-exports.js` - Limpiar duplicados
- ✅ `scripts/fix-broken-exports.js` - Arreglar exports mal insertados

### Resultados
- ✅ Build compila exitosamente
- ✅ Todas las rutas API protegidas contra ejecución en build time
- ✅ Cliente Supabase no se crea en top-level
- ✅ Factory functions implementadas correctamente

## TAREA 2B COMPLETADA ✅ - Fix "supabaseKey is required"

### Problema Identificado
- ✅ **7 archivos** con `createClient` en top-level encontrados
- ✅ **@supabase/auth-helpers-nextjs** detectado en package.json
- ✅ **"supabaseKey is required"** causado por helpers SSR

### Factory SSR Seguro
- ✅ `lib/supabase/ssr.ts` - Factory SSR con cookies
- ✅ `getSupabaseSSR()` - Para server components con sesiones
- ✅ Validación de ENV en runtime

### Archivos Arreglados
- ✅ `lib/cultural-context/CulturalContextService.ts`
- ✅ `lib/auth/server-auth.ts`
- ✅ `app/api/jobs/run/route.ts`
- ✅ `app/api/games/next/route.ts`
- ✅ `app/api/pool/ensure/route.ts`
- ✅ `app/api/pool/category/route.ts`
- ✅ `app/api/pool/usage/route.ts`

### Guardia ENV Mejorada
- ✅ `scripts/verify-env.mjs` - Soporte para CHECK_SERVICE_ROLE
- ✅ Verificación condicional de SERVICE_ROLE_KEY
- ✅ Falla rápido si faltan ENV requeridas

### Scripts de Automatización
- ✅ `scripts/fix-supabase-top-level.js` - Arreglar instancias top-level
- ✅ Reemplazo automático de `createClient` por `getSupabaseServer()`
- ✅ Factory calls agregadas en funciones que usan supabase

### Verificación de Runtime
- ✅ **No hay runtime=edge con SERVICE_ROLE** (solo health endpoint)
- ✅ Todas las rutas API usan `runtime = 'nodejs'`
- ✅ Factory lazy implementado correctamente

## TAREA 2 COMPLETADA ✅ - Factory Lazy Implementado

### Cliente Supabase Factory Lazy
- ✅ `lib/supabase/server.ts` - Factory lazy implementado
- ✅ Función `required()` para validación de ENV en runtime
- ✅ `getSupabaseServer(useServiceRole = false)` - Factory principal
- ✅ `getServiceRoleClient()` - Alias para service role
- ✅ Headers de identificación agregados

### Guardia Previa al Build
- ✅ `scripts/verify-env.mjs` - Verificación de ENV requeridas
- ✅ `package.json` - prebuild script configurado
- ✅ Falla rápido si faltan ENV (no en mitad del deploy)

### Health Endpoint
- ✅ `app/api/_health/route.ts` - Smoke test runtime
- ✅ Conexión a Supabase verificada
- ✅ Respuesta JSON con timestamp

### GitHub Actions
- ✅ `.github/workflows/postdeploy.yml` - Post-deploy check
- ✅ Workflow dispatch manual
- ✅ Soporte para production y preview
- ✅ Notificación de fallos

### Patrón Factory Lazy Implementado
```typescript
// Factory lazy - se crea solo cuando se llama
export function getSupabaseServer(useServiceRole = false) {
  const url = required('NEXT_PUBLIC_SUPABASE_URL');
  const key = useServiceRole
    ? required('SUPABASE_SERVICE_ROLE_KEY')
    : required('NEXT_PUBLIC_SUPABASE_ANON_KEY');

  return createClient(url, key, {
    auth: { persistSession: false },
    global: { headers: { 'X-Client-Info': 'fuzzys-web@1.0.0' } },
  });
}
```

### Uso en Rutas API
```typescript
export async function POST(req: Request) {
  try {
    const supabase = getSupabaseServer(true); // useServiceRole = true
    // ... lógica con supabase
    return NextResponse.json({ ok: true });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message ?? 'Server error' }, { status: 500 });
  }
}
```
